{"ast":null,"code":"// Copyright (c) 2011, Chris Umbel, James Coglan\n// Plane class - depends on Vector. Some methods require Matrix and Line.\nvar Vector = require('./vector');\n\nvar Matrix = require('./matrix');\n\nvar Line = require('./line');\n\nvar Sylvester = require('./sylvester');\n\nfunction Plane() {}\n\nPlane.prototype = {\n  // Returns true iff the plane occupies the same space as the argument\n  eql: function (plane) {\n    return this.contains(plane.anchor) && this.isParallelTo(plane);\n  },\n  // Returns a copy of the plane\n  dup: function () {\n    return Plane.create(this.anchor, this.normal);\n  },\n  // Returns the result of translating the plane by the given vector\n  translate: function (vector) {\n    var V = vector.elements || vector;\n    return Plane.create([this.anchor.elements[0] + V[0], this.anchor.elements[1] + V[1], this.anchor.elements[2] + (V[2] || 0)], this.normal);\n  },\n  // Returns true iff the plane is parallel to the argument. Will return true\n  // if the planes are equal, or if you give a line and it lies in the plane.\n  isParallelTo: function (obj) {\n    var theta;\n\n    if (obj.normal) {\n      // obj is a plane\n      theta = this.normal.angleFrom(obj.normal);\n      return Math.abs(theta) <= Sylvester.precision || Math.abs(Math.PI - theta) <= Sylvester.precision;\n    } else if (obj.direction) {\n      // obj is a line\n      return this.normal.isPerpendicularTo(obj.direction);\n    }\n\n    return null;\n  },\n  // Returns true iff the receiver is perpendicular to the argument\n  isPerpendicularTo: function (plane) {\n    var theta = this.normal.angleFrom(plane.normal);\n    return Math.abs(Math.PI / 2 - theta) <= Sylvester.precision;\n  },\n  // Returns the plane's distance from the given object (point, line or plane)\n  distanceFrom: function (obj) {\n    if (this.intersects(obj) || this.contains(obj)) {\n      return 0;\n    }\n\n    if (obj.anchor) {\n      // obj is a plane or line\n      var A = this.anchor.elements,\n          B = obj.anchor.elements,\n          N = this.normal.elements;\n      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      var A = this.anchor.elements,\n          N = this.normal.elements;\n      return Math.abs((A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2]);\n    }\n  },\n  // Returns true iff the plane contains the given point or line\n  contains: function (obj) {\n    if (obj.normal) {\n      return null;\n    }\n\n    if (obj.direction) {\n      return this.contains(obj.anchor) && this.contains(obj.anchor.add(obj.direction));\n    } else {\n      var P = obj.elements || obj;\n      var A = this.anchor.elements,\n          N = this.normal.elements;\n      var diff = Math.abs(N[0] * (A[0] - P[0]) + N[1] * (A[1] - P[1]) + N[2] * (A[2] - (P[2] || 0)));\n      return diff <= Sylvester.precision;\n    }\n  },\n  // Returns true iff the plane has a unique point/line of intersection with the argument\n  intersects: function (obj) {\n    if (typeof obj.direction == 'undefined' && typeof obj.normal == 'undefined') {\n      return null;\n    }\n\n    return !this.isParallelTo(obj);\n  },\n  // Returns the unique intersection with the argument, if one exists. The result\n  // will be a vector if a line is supplied, and a line if a plane is supplied.\n  intersectionWith: function (obj) {\n    if (!this.intersects(obj)) {\n      return null;\n    }\n\n    if (obj.direction) {\n      // obj is a line\n      var A = obj.anchor.elements,\n          D = obj.direction.elements,\n          P = this.anchor.elements,\n          N = this.normal.elements;\n      var multiplier = (N[0] * (P[0] - A[0]) + N[1] * (P[1] - A[1]) + N[2] * (P[2] - A[2])) / (N[0] * D[0] + N[1] * D[1] + N[2] * D[2]);\n      return Vector.create([A[0] + D[0] * multiplier, A[1] + D[1] * multiplier, A[2] + D[2] * multiplier]);\n    } else if (obj.normal) {\n      // obj is a plane\n      var direction = this.normal.cross(obj.normal).toUnitVector(); // To find an anchor point, we find one co-ordinate that has a value\n      // of zero somewhere on the intersection, and remember which one we picked\n\n      var N = this.normal.elements,\n          A = this.anchor.elements,\n          O = obj.normal.elements,\n          B = obj.anchor.elements;\n      var solver = Matrix.Zero(2, 2),\n          i = 0;\n\n      while (solver.isSingular()) {\n        i++;\n        solver = Matrix.create([[N[i % 3], N[(i + 1) % 3]], [O[i % 3], O[(i + 1) % 3]]]);\n      } // Then we solve the simultaneous equations in the remaining dimensions\n\n\n      var inverse = solver.inverse().elements;\n      var x = N[0] * A[0] + N[1] * A[1] + N[2] * A[2];\n      var y = O[0] * B[0] + O[1] * B[1] + O[2] * B[2];\n      var intersection = [inverse[0][0] * x + inverse[0][1] * y, inverse[1][0] * x + inverse[1][1] * y];\n      var anchor = [];\n\n      for (var j = 1; j <= 3; j++) {\n        // This formula picks the right element from intersection by\n        // cycling depending on which element we set to zero above\n        anchor.push(i == j ? 0 : intersection[(j + (5 - i) % 3) % 3]);\n      }\n\n      return Line.create(anchor, direction);\n    }\n  },\n  // Returns the point in the plane closest to the given point\n  pointClosestTo: function (point) {\n    var P = point.elements || point;\n    var A = this.anchor.elements,\n        N = this.normal.elements;\n    var dot = (A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2];\n    return Vector.create([P[0] + N[0] * dot, P[1] + N[1] * dot, (P[2] || 0) + N[2] * dot]);\n  },\n  // Returns a copy of the plane, rotated by t radians about the given line\n  // See notes on Line#rotate.\n  rotate: function (t, line) {\n    var R = t.determinant ? t.elements : Matrix.Rotation(t, line.direction).elements;\n    var C = line.pointClosestTo(this.anchor).elements;\n    var A = this.anchor.elements,\n        N = this.normal.elements;\n    var C1 = C[0],\n        C2 = C[1],\n        C3 = C[2],\n        A1 = A[0],\n        A2 = A[1],\n        A3 = A[2];\n    var x = A1 - C1,\n        y = A2 - C2,\n        z = A3 - C3;\n    return Plane.create([C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z, C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z, C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z], [R[0][0] * N[0] + R[0][1] * N[1] + R[0][2] * N[2], R[1][0] * N[0] + R[1][1] * N[1] + R[1][2] * N[2], R[2][0] * N[0] + R[2][1] * N[1] + R[2][2] * N[2]]);\n  },\n  // Returns the reflection of the plane in the given point, line or plane.\n  reflectionIn: function (obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var A = this.anchor.elements,\n          N = this.normal.elements;\n      var A1 = A[0],\n          A2 = A[1],\n          A3 = A[2],\n          N1 = N[0],\n          N2 = N[1],\n          N3 = N[2];\n      var newA = this.anchor.reflectionIn(obj).elements; // Add the plane's normal to its anchor, then mirror that in the other plane\n\n      var AN1 = A1 + N1,\n          AN2 = A2 + N2,\n          AN3 = A3 + N3;\n      var Q = obj.pointClosestTo([AN1, AN2, AN3]).elements;\n      var newN = [Q[0] + (Q[0] - AN1) - newA[0], Q[1] + (Q[1] - AN2) - newA[1], Q[2] + (Q[2] - AN3) - newA[2]];\n      return Plane.create(newA, newN);\n    } else if (obj.direction) {\n      // obj is a line\n      return this.rotate(Math.PI, obj);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      return Plane.create(this.anchor.reflectionIn([P[0], P[1], P[2] || 0]), this.normal);\n    }\n  },\n  // Sets the anchor point and normal to the plane. If three arguments are specified,\n  // the normal is calculated by assuming the three points should lie in the same plane.\n  // If only two are sepcified, the second is taken to be the normal. Normal vector is\n  // normalised before storage.\n  setVectors: function (anchor, v1, v2) {\n    anchor = Vector.create(anchor);\n    anchor = anchor.to3D();\n\n    if (anchor === null) {\n      return null;\n    }\n\n    v1 = Vector.create(v1);\n    v1 = v1.to3D();\n\n    if (v1 === null) {\n      return null;\n    }\n\n    if (typeof v2 == 'undefined') {\n      v2 = null;\n    } else {\n      v2 = Vector.create(v2);\n      v2 = v2.to3D();\n\n      if (v2 === null) {\n        return null;\n      }\n    }\n\n    var A1 = anchor.elements[0],\n        A2 = anchor.elements[1],\n        A3 = anchor.elements[2];\n    var v11 = v1.elements[0],\n        v12 = v1.elements[1],\n        v13 = v1.elements[2];\n    var normal, mod;\n\n    if (v2 !== null) {\n      var v21 = v2.elements[0],\n          v22 = v2.elements[1],\n          v23 = v2.elements[2];\n      normal = Vector.create([(v12 - A2) * (v23 - A3) - (v13 - A3) * (v22 - A2), (v13 - A3) * (v21 - A1) - (v11 - A1) * (v23 - A3), (v11 - A1) * (v22 - A2) - (v12 - A2) * (v21 - A1)]);\n      mod = normal.modulus();\n\n      if (mod === 0) {\n        return null;\n      }\n\n      normal = Vector.create([normal.elements[0] / mod, normal.elements[1] / mod, normal.elements[2] / mod]);\n    } else {\n      mod = Math.sqrt(v11 * v11 + v12 * v12 + v13 * v13);\n\n      if (mod === 0) {\n        return null;\n      }\n\n      normal = Vector.create([v1.elements[0] / mod, v1.elements[1] / mod, v1.elements[2] / mod]);\n    }\n\n    this.anchor = anchor;\n    this.normal = normal;\n    return this;\n  }\n}; // Constructor function\n\nPlane.create = function (anchor, v1, v2) {\n  var P = new Plane();\n  return P.setVectors(anchor, v1, v2);\n}; // X-Y-Z planes\n\n\nPlane.XY = Plane.create(Vector.Zero(3), Vector.k);\nPlane.YZ = Plane.create(Vector.Zero(3), Vector.i);\nPlane.ZX = Plane.create(Vector.Zero(3), Vector.j);\nPlane.YX = Plane.XY;\nPlane.ZY = Plane.YZ;\nPlane.XZ = Plane.ZX; // Returns the plane containing the given points (can be arrays as\n// well as vectors). If the points are not coplanar, returns null.\n\nPlane.fromPoints = function (points) {\n  var np = points.length,\n      list = [],\n      i,\n      P,\n      n,\n      N,\n      A,\n      B,\n      C,\n      D,\n      theta,\n      prevN,\n      totalN = Vector.Zero(3);\n\n  for (i = 0; i < np; i++) {\n    P = Vector.create(points[i]).to3D();\n\n    if (P === null) {\n      return null;\n    }\n\n    list.push(P);\n    n = list.length;\n\n    if (n > 2) {\n      // Compute plane normal for the latest three points\n      A = list[n - 1].elements;\n      B = list[n - 2].elements;\n      C = list[n - 3].elements;\n      N = Vector.create([(A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]), (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]), (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])]).toUnitVector();\n\n      if (n > 3) {\n        // If the latest normal is not (anti)parallel to the previous one, we've strayed off the plane.\n        // This might be a slightly long-winded way of doing things, but we need the sum of all the normals\n        // to find which way the plane normal should point so that the points form an anticlockwise list.\n        theta = N.angleFrom(prevN);\n\n        if (theta !== null) {\n          if (!(Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision)) {\n            return null;\n          }\n        }\n      }\n\n      totalN = totalN.add(N);\n      prevN = N;\n    }\n  } // We need to add in the normals at the start and end points, which the above misses out\n\n\n  A = list[1].elements;\n  B = list[0].elements;\n  C = list[n - 1].elements;\n  D = list[n - 2].elements;\n  totalN = totalN.add(Vector.create([(A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]), (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]), (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])]).toUnitVector()).add(Vector.create([(B[1] - C[1]) * (D[2] - C[2]) - (B[2] - C[2]) * (D[1] - C[1]), (B[2] - C[2]) * (D[0] - C[0]) - (B[0] - C[0]) * (D[2] - C[2]), (B[0] - C[0]) * (D[1] - C[1]) - (B[1] - C[1]) * (D[0] - C[0])]).toUnitVector());\n  return Plane.create(list[0], totalN);\n};\n\nmodule.exports = Plane;","map":{"version":3,"sources":["/Users/merjem/chat_application/react/node_modules/sylvester/lib/node-sylvester/plane.js"],"names":["Vector","require","Matrix","Line","Sylvester","Plane","prototype","eql","plane","contains","anchor","isParallelTo","dup","create","normal","translate","vector","V","elements","obj","theta","angleFrom","Math","abs","precision","PI","direction","isPerpendicularTo","distanceFrom","intersects","A","B","N","P","add","diff","intersectionWith","D","multiplier","cross","toUnitVector","O","solver","Zero","i","isSingular","inverse","x","y","intersection","j","push","pointClosestTo","point","dot","rotate","t","line","R","determinant","Rotation","C","C1","C2","C3","A1","A2","A3","z","reflectionIn","N1","N2","N3","newA","AN1","AN2","AN3","Q","newN","setVectors","v1","v2","to3D","v11","v12","v13","mod","v21","v22","v23","modulus","sqrt","XY","k","YZ","ZX","YX","ZY","XZ","fromPoints","points","np","length","list","n","prevN","totalN","module","exports"],"mappings":"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","sourcesContent":["// Copyright (c) 2011, Chris Umbel, James Coglan\n// Plane class - depends on Vector. Some methods require Matrix and Line.\nvar Vector = require('./vector');\nvar Matrix = require('./matrix');\nvar Line = require('./line');\n\nvar Sylvester = require('./sylvester');\n\nfunction Plane() {}\nPlane.prototype = {\n\n  // Returns true iff the plane occupies the same space as the argument\n  eql: function(plane) {\n    return (this.contains(plane.anchor) && this.isParallelTo(plane));\n  },\n\n  // Returns a copy of the plane\n  dup: function() {\n    return Plane.create(this.anchor, this.normal);\n  },\n\n  // Returns the result of translating the plane by the given vector\n  translate: function(vector) {\n    var V = vector.elements || vector;\n    return Plane.create([\n      this.anchor.elements[0] + V[0],\n      this.anchor.elements[1] + V[1],\n      this.anchor.elements[2] + (V[2] || 0)\n    ], this.normal);\n  },\n\n  // Returns true iff the plane is parallel to the argument. Will return true\n  // if the planes are equal, or if you give a line and it lies in the plane.\n  isParallelTo: function(obj) {\n    var theta;\n    if (obj.normal) {\n      // obj is a plane\n      theta = this.normal.angleFrom(obj.normal);\n      return (Math.abs(theta) <= Sylvester.precision || Math.abs(Math.PI - theta) <= Sylvester.precision);\n    } else if (obj.direction) {\n      // obj is a line\n      return this.normal.isPerpendicularTo(obj.direction);\n    }\n    return null;\n  },\n\n  // Returns true iff the receiver is perpendicular to the argument\n  isPerpendicularTo: function(plane) {\n    var theta = this.normal.angleFrom(plane.normal);\n    return (Math.abs(Math.PI/2 - theta) <= Sylvester.precision);\n  },\n\n  // Returns the plane's distance from the given object (point, line or plane)\n  distanceFrom: function(obj) {\n    if (this.intersects(obj) || this.contains(obj)) { return 0; }\n    if (obj.anchor) {\n      // obj is a plane or line\n      var A = this.anchor.elements, B = obj.anchor.elements, N = this.normal.elements;\n      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      var A = this.anchor.elements, N = this.normal.elements;\n      return Math.abs((A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2]);\n    }\n  },\n\n  // Returns true iff the plane contains the given point or line\n  contains: function(obj) {\n    if (obj.normal) { return null; }\n    if (obj.direction) {\n      return (this.contains(obj.anchor) && this.contains(obj.anchor.add(obj.direction)));\n    } else {\n      var P = obj.elements || obj;\n      var A = this.anchor.elements, N = this.normal.elements;\n      var diff = Math.abs(N[0]*(A[0] - P[0]) + N[1]*(A[1] - P[1]) + N[2]*(A[2] - (P[2] || 0)));\n      return (diff <= Sylvester.precision);\n    }\n  },\n\n  // Returns true iff the plane has a unique point/line of intersection with the argument\n  intersects: function(obj) {\n    if (typeof(obj.direction) == 'undefined' && typeof(obj.normal) == 'undefined') { return null; }\n    return !this.isParallelTo(obj);\n  },\n\n  // Returns the unique intersection with the argument, if one exists. The result\n  // will be a vector if a line is supplied, and a line if a plane is supplied.\n  intersectionWith: function(obj) {\n    if (!this.intersects(obj)) { return null; }\n    if (obj.direction) {\n      // obj is a line\n      var A = obj.anchor.elements, D = obj.direction.elements,\n          P = this.anchor.elements, N = this.normal.elements;\n      var multiplier = (N[0]*(P[0]-A[0]) + N[1]*(P[1]-A[1]) + N[2]*(P[2]-A[2])) / (N[0]*D[0] + N[1]*D[1] + N[2]*D[2]);\n      return Vector.create([A[0] + D[0]*multiplier, A[1] + D[1]*multiplier, A[2] + D[2]*multiplier]);\n    } else if (obj.normal) {\n      // obj is a plane\n      var direction = this.normal.cross(obj.normal).toUnitVector();\n      // To find an anchor point, we find one co-ordinate that has a value\n      // of zero somewhere on the intersection, and remember which one we picked\n      var N = this.normal.elements, A = this.anchor.elements,\n          O = obj.normal.elements, B = obj.anchor.elements;\n      var solver = Matrix.Zero(2,2), i = 0;\n      while (solver.isSingular()) {\n        i++;\n        solver = Matrix.create([\n          [ N[i%3], N[(i+1)%3] ],\n          [ O[i%3], O[(i+1)%3]  ]\n        ]);\n      }\n      // Then we solve the simultaneous equations in the remaining dimensions\n      var inverse = solver.inverse().elements;\n      var x = N[0]*A[0] + N[1]*A[1] + N[2]*A[2];\n      var y = O[0]*B[0] + O[1]*B[1] + O[2]*B[2];\n      var intersection = [\n        inverse[0][0] * x + inverse[0][1] * y,\n        inverse[1][0] * x + inverse[1][1] * y\n      ];\n      var anchor = [];\n      for (var j = 1; j <= 3; j++) {\n        // This formula picks the right element from intersection by\n        // cycling depending on which element we set to zero above\n        anchor.push((i == j) ? 0 : intersection[(j + (5 - i)%3)%3]);\n      }\n      return Line.create(anchor, direction);\n    }\n  },\n\n  // Returns the point in the plane closest to the given point\n  pointClosestTo: function(point) {\n    var P = point.elements || point;\n    var A = this.anchor.elements, N = this.normal.elements;\n    var dot = (A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2];\n    return Vector.create([P[0] + N[0] * dot, P[1] + N[1] * dot, (P[2] || 0) + N[2] * dot]);\n  },\n\n  // Returns a copy of the plane, rotated by t radians about the given line\n  // See notes on Line#rotate.\n  rotate: function(t, line) {\n    var R = t.determinant ? t.elements : Matrix.Rotation(t, line.direction).elements;\n    var C = line.pointClosestTo(this.anchor).elements;\n    var A = this.anchor.elements, N = this.normal.elements;\n    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];\n    var x = A1 - C1, y = A2 - C2, z = A3 - C3;\n    return Plane.create([\n      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,\n      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,\n      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z\n    ], [\n      R[0][0] * N[0] + R[0][1] * N[1] + R[0][2] * N[2],\n      R[1][0] * N[0] + R[1][1] * N[1] + R[1][2] * N[2],\n      R[2][0] * N[0] + R[2][1] * N[1] + R[2][2] * N[2]\n    ]);\n  },\n\n  // Returns the reflection of the plane in the given point, line or plane.\n  reflectionIn: function(obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var A = this.anchor.elements, N = this.normal.elements;\n      var A1 = A[0], A2 = A[1], A3 = A[2], N1 = N[0], N2 = N[1], N3 = N[2];\n      var newA = this.anchor.reflectionIn(obj).elements;\n      // Add the plane's normal to its anchor, then mirror that in the other plane\n      var AN1 = A1 + N1, AN2 = A2 + N2, AN3 = A3 + N3;\n      var Q = obj.pointClosestTo([AN1, AN2, AN3]).elements;\n      var newN = [Q[0] + (Q[0] - AN1) - newA[0], Q[1] + (Q[1] - AN2) - newA[1], Q[2] + (Q[2] - AN3) - newA[2]];\n      return Plane.create(newA, newN);\n    } else if (obj.direction) {\n      // obj is a line\n      return this.rotate(Math.PI, obj);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      return Plane.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.normal);\n    }\n  },\n\n  // Sets the anchor point and normal to the plane. If three arguments are specified,\n  // the normal is calculated by assuming the three points should lie in the same plane.\n  // If only two are sepcified, the second is taken to be the normal. Normal vector is\n  // normalised before storage.\n  setVectors: function(anchor, v1, v2) {\n    anchor = Vector.create(anchor);\n    anchor = anchor.to3D(); if (anchor === null) { return null; }\n    v1 = Vector.create(v1);\n    v1 = v1.to3D(); if (v1 === null) { return null; }\n    if (typeof(v2) == 'undefined') {\n      v2 = null;\n    } else {\n      v2 = Vector.create(v2);\n      v2 = v2.to3D(); if (v2 === null) { return null; }\n    }\n    var A1 = anchor.elements[0], A2 = anchor.elements[1], A3 = anchor.elements[2];\n    var v11 = v1.elements[0], v12 = v1.elements[1], v13 = v1.elements[2];\n    var normal, mod;\n    if (v2 !== null) {\n      var v21 = v2.elements[0], v22 = v2.elements[1], v23 = v2.elements[2];\n      normal = Vector.create([\n        (v12 - A2) * (v23 - A3) - (v13 - A3) * (v22 - A2),\n        (v13 - A3) * (v21 - A1) - (v11 - A1) * (v23 - A3),\n        (v11 - A1) * (v22 - A2) - (v12 - A2) * (v21 - A1)\n      ]);\n      mod = normal.modulus();\n      if (mod === 0) { return null; }\n      normal = Vector.create([normal.elements[0] / mod, normal.elements[1] / mod, normal.elements[2] / mod]);\n    } else {\n      mod = Math.sqrt(v11*v11 + v12*v12 + v13*v13);\n      if (mod === 0) { return null; }\n      normal = Vector.create([v1.elements[0] / mod, v1.elements[1] / mod, v1.elements[2] / mod]);\n    }\n    this.anchor = anchor;\n    this.normal = normal;\n    return this;\n  }\n};\n\n// Constructor function\nPlane.create = function(anchor, v1, v2) {\n  var P = new Plane();\n  return P.setVectors(anchor, v1, v2);\n};\n\n// X-Y-Z planes\nPlane.XY = Plane.create(Vector.Zero(3), Vector.k);\nPlane.YZ = Plane.create(Vector.Zero(3), Vector.i);\nPlane.ZX = Plane.create(Vector.Zero(3), Vector.j);\nPlane.YX = Plane.XY; Plane.ZY = Plane.YZ; Plane.XZ = Plane.ZX;\n\n// Returns the plane containing the given points (can be arrays as\n// well as vectors). If the points are not coplanar, returns null.\nPlane.fromPoints = function(points) {\n  var np = points.length, list = [], i, P, n, N, A, B, C, D, theta, prevN, totalN = Vector.Zero(3);\n  for (i = 0; i < np; i++) {\n    P = Vector.create(points[i]).to3D();\n    if (P === null) { return null; }\n    list.push(P);\n    n = list.length;\n    if (n > 2) {\n      // Compute plane normal for the latest three points\n      A = list[n-1].elements; B = list[n-2].elements; C = list[n-3].elements;\n      N = Vector.create([\n        (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),\n        (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),\n        (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])\n      ]).toUnitVector();\n      if (n > 3) {\n        // If the latest normal is not (anti)parallel to the previous one, we've strayed off the plane.\n        // This might be a slightly long-winded way of doing things, but we need the sum of all the normals\n        // to find which way the plane normal should point so that the points form an anticlockwise list.\n        theta = N.angleFrom(prevN);\n        if (theta !== null) {\n          if (!(Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision)) { return null; }\n        }\n      }\n      totalN = totalN.add(N);\n      prevN = N;\n    }\n  }\n  // We need to add in the normals at the start and end points, which the above misses out\n  A = list[1].elements; B = list[0].elements; C = list[n-1].elements; D = list[n-2].elements;\n  totalN = totalN.add(Vector.create([\n    (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),\n    (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),\n    (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])\n  ]).toUnitVector()).add(Vector.create([\n    (B[1] - C[1]) * (D[2] - C[2]) - (B[2] - C[2]) * (D[1] - C[1]),\n    (B[2] - C[2]) * (D[0] - C[0]) - (B[0] - C[0]) * (D[2] - C[2]),\n    (B[0] - C[0]) * (D[1] - C[1]) - (B[1] - C[1]) * (D[0] - C[0])\n  ]).toUnitVector());\n  return Plane.create(list[0], totalN);\n};\n\nmodule.exports = Plane;\n"]},"metadata":{},"sourceType":"script"}