{"ast":null,"code":"// Copyright (c) 2011, Chris Umbel, James Coglan\n// Line.Segment class - depends on Line and its dependencies.\nvar Line = require('./line');\n\nvar Vector = require('./vector');\n\nLine.Segment = function () {};\n\nLine.Segment.prototype = {\n  // Returns true iff the line segment is equal to the argument\n  eql: function (segment) {\n    return this.start.eql(segment.start) && this.end.eql(segment.end) || this.start.eql(segment.end) && this.end.eql(segment.start);\n  },\n  // Returns a copy of the line segment\n  dup: function () {\n    return Line.Segment.create(this.start, this.end);\n  },\n  // Returns the length of the line segment\n  length: function () {\n    var A = this.start.elements,\n        B = this.end.elements;\n    var C1 = B[0] - A[0],\n        C2 = B[1] - A[1],\n        C3 = B[2] - A[2];\n    return Math.sqrt(C1 * C1 + C2 * C2 + C3 * C3);\n  },\n  // Returns the line segment as a vector equal to its\n  // end point relative to its endpoint\n  toVector: function () {\n    var A = this.start.elements,\n        B = this.end.elements;\n    return Vector.create([B[0] - A[0], B[1] - A[1], B[2] - A[2]]);\n  },\n  // Returns the segment's midpoint as a vector\n  midpoint: function () {\n    var A = this.start.elements,\n        B = this.end.elements;\n    return Vector.create([(B[0] + A[0]) / 2, (B[1] + A[1]) / 2, (B[2] + A[2]) / 2]);\n  },\n  // Returns the plane that bisects the segment\n  bisectingPlane: function () {\n    return Plane.create(this.midpoint(), this.toVector());\n  },\n  // Returns the result of translating the line by the given vector/array\n  translate: function (vector) {\n    var V = vector.elements || vector;\n    var S = this.start.elements,\n        E = this.end.elements;\n    return Line.Segment.create([S[0] + V[0], S[1] + V[1], S[2] + (V[2] || 0)], [E[0] + V[0], E[1] + V[1], E[2] + (V[2] || 0)]);\n  },\n  // Returns true iff the line segment is parallel to the argument. It simply forwards\n  // the method call onto its line property.\n  isParallelTo: function (obj) {\n    return this.line.isParallelTo(obj);\n  },\n  // Returns the distance between the argument and the line segment's closest point to the argument\n  distanceFrom: function (obj) {\n    var P = this.pointClosestTo(obj);\n    return P === null ? null : P.distanceFrom(obj);\n  },\n  // Returns true iff the given point lies on the segment\n  contains: function (obj) {\n    if (obj.start && obj.end) {\n      return this.contains(obj.start) && this.contains(obj.end);\n    }\n\n    var P = (obj.elements || obj).slice();\n\n    if (P.length == 2) {\n      P.push(0);\n    }\n\n    if (this.start.eql(P)) {\n      return true;\n    }\n\n    var S = this.start.elements;\n    var V = Vector.create([S[0] - P[0], S[1] - P[1], S[2] - (P[2] || 0)]);\n    var vect = this.toVector();\n    return V.isAntiparallelTo(vect) && V.modulus() <= vect.modulus();\n  },\n  // Returns true iff the line segment intersects the argument\n  intersects: function (obj) {\n    return this.intersectionWith(obj) !== null;\n  },\n  // Returns the unique point of intersection with the argument\n  intersectionWith: function (obj) {\n    if (!this.line.intersects(obj)) {\n      return null;\n    }\n\n    var P = this.line.intersectionWith(obj);\n    return this.contains(P) ? P : null;\n  },\n  // Returns the point on the line segment closest to the given object\n  pointClosestTo: function (obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var V = this.line.intersectionWith(obj);\n\n      if (V === null) {\n        return null;\n      }\n\n      return this.pointClosestTo(V);\n    } else {\n      // obj is a line (segment) or point\n      var P = this.line.pointClosestTo(obj);\n\n      if (P === null) {\n        return null;\n      }\n\n      if (this.contains(P)) {\n        return P;\n      }\n\n      return (this.line.positionOf(P) < 0 ? this.start : this.end).dup();\n    }\n  },\n  // Set the start and end-points of the segment\n  setPoints: function (startPoint, endPoint) {\n    startPoint = Vector.create(startPoint).to3D();\n    endPoint = Vector.create(endPoint).to3D();\n\n    if (startPoint === null || endPoint === null) {\n      return null;\n    }\n\n    this.line = Line.create(startPoint, endPoint.subtract(startPoint));\n    this.start = startPoint;\n    this.end = endPoint;\n    return this;\n  }\n}; // Constructor function\n\nLine.Segment.create = function (v1, v2) {\n  var S = new Line.Segment();\n  return S.setPoints(v1, v2);\n};\n\nmodule.exports = Line.Segment;","map":{"version":3,"sources":["/Users/merjem/chat_application/react/node_modules/sylvester/lib/node-sylvester/line.segment.js"],"names":["Line","require","Vector","Segment","prototype","eql","segment","start","end","dup","create","length","A","elements","B","C1","C2","C3","Math","sqrt","toVector","midpoint","bisectingPlane","Plane","translate","vector","V","S","E","isParallelTo","obj","line","distanceFrom","P","pointClosestTo","contains","slice","push","vect","isAntiparallelTo","modulus","intersects","intersectionWith","normal","positionOf","setPoints","startPoint","endPoint","to3D","subtract","v1","v2","module","exports"],"mappings":"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","sourcesContent":["// Copyright (c) 2011, Chris Umbel, James Coglan\n// Line.Segment class - depends on Line and its dependencies.\n\nvar Line = require('./line');\nvar Vector = require('./vector');\n\nLine.Segment = function() {};\nLine.Segment.prototype = {\n\n  // Returns true iff the line segment is equal to the argument\n  eql: function(segment) {\n    return (this.start.eql(segment.start) && this.end.eql(segment.end)) ||\n        (this.start.eql(segment.end) && this.end.eql(segment.start));\n  },\n\n  // Returns a copy of the line segment\n  dup: function() {\n    return Line.Segment.create(this.start, this.end);\n  },\n\n  // Returns the length of the line segment\n  length: function() {\n    var A = this.start.elements, B = this.end.elements;\n    var C1 = B[0] - A[0], C2 = B[1] - A[1], C3 = B[2] - A[2];\n    return Math.sqrt(C1*C1 + C2*C2 + C3*C3);\n  },\n\n  // Returns the line segment as a vector equal to its\n  // end point relative to its endpoint\n  toVector: function() {\n    var A = this.start.elements, B = this.end.elements;\n    return Vector.create([B[0] - A[0], B[1] - A[1], B[2] - A[2]]);\n  },\n\n  // Returns the segment's midpoint as a vector\n  midpoint: function() {\n    var A = this.start.elements, B = this.end.elements;\n    return Vector.create([(B[0] + A[0])/2, (B[1] + A[1])/2, (B[2] + A[2])/2]);\n  },\n\n  // Returns the plane that bisects the segment\n  bisectingPlane: function() {\n    return Plane.create(this.midpoint(), this.toVector());\n  },\n\n  // Returns the result of translating the line by the given vector/array\n  translate: function(vector) {\n    var V = vector.elements || vector;\n    var S = this.start.elements, E = this.end.elements;\n    return Line.Segment.create(\n      [S[0] + V[0], S[1] + V[1], S[2] + (V[2] || 0)],\n      [E[0] + V[0], E[1] + V[1], E[2] + (V[2] || 0)]\n    );\n  },\n\n  // Returns true iff the line segment is parallel to the argument. It simply forwards\n  // the method call onto its line property.\n  isParallelTo: function(obj) {\n    return this.line.isParallelTo(obj);\n  },\n\n  // Returns the distance between the argument and the line segment's closest point to the argument\n  distanceFrom: function(obj) {\n    var P = this.pointClosestTo(obj);\n    return (P === null) ? null : P.distanceFrom(obj);\n  },\n\n  // Returns true iff the given point lies on the segment\n  contains: function(obj) {\n    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }\n    var P = (obj.elements || obj).slice();\n    if (P.length == 2) { P.push(0); }\n    if (this.start.eql(P)) { return true; }\n    var S = this.start.elements;\n    var V = Vector.create([S[0] - P[0], S[1] - P[1], S[2] - (P[2] || 0)]);\n    var vect = this.toVector();\n    return V.isAntiparallelTo(vect) && V.modulus() <= vect.modulus();\n  },\n\n  // Returns true iff the line segment intersects the argument\n  intersects: function(obj) {\n    return (this.intersectionWith(obj) !== null);\n  },\n\n  // Returns the unique point of intersection with the argument\n  intersectionWith: function(obj) {\n    if (!this.line.intersects(obj)) { return null; }\n    var P = this.line.intersectionWith(obj);\n    return (this.contains(P) ? P : null);\n  },\n\n  // Returns the point on the line segment closest to the given object\n  pointClosestTo: function(obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var V = this.line.intersectionWith(obj);\n      if (V === null) { return null; }\n      return this.pointClosestTo(V);\n    } else {\n      // obj is a line (segment) or point\n      var P = this.line.pointClosestTo(obj);\n      if (P === null) { return null; }\n      if (this.contains(P)) { return P; }\n      return (this.line.positionOf(P) < 0 ? this.start : this.end).dup();\n    }\n  },\n\n  // Set the start and end-points of the segment\n  setPoints: function(startPoint, endPoint) {\n    startPoint = Vector.create(startPoint).to3D();\n    endPoint = Vector.create(endPoint).to3D();\n    if (startPoint === null || endPoint === null) { return null; }\n    this.line = Line.create(startPoint, endPoint.subtract(startPoint));\n    this.start = startPoint;\n    this.end = endPoint;\n    return this;\n  }\n};\n\n// Constructor function\nLine.Segment.create = function(v1, v2) {\n  var S = new Line.Segment();\n  return S.setPoints(v1, v2);\n};\n\nmodule.exports = Line.Segment;\n"]},"metadata":{},"sourceType":"script"}