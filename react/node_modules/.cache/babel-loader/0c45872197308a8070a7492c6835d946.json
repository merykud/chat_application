{"ast":null,"code":"// Copyright (c) 2011, Chris Umbel, James Coglan\nvar Vector = require('./vector');\n\nvar Matrix = require('./matrix');\n\nvar Plane = require('./plane');\n\nvar Sylvester = require('./sylvester'); // Line class - depends on Vector, and some methods require Matrix and Plane.\n\n\nfunction Line() {}\n\nLine.prototype = {\n  // Returns true if the argument occupies the same space as the line\n  eql: function (line) {\n    return this.isParallelTo(line) && this.contains(line.anchor);\n  },\n  // Returns a copy of the line\n  dup: function () {\n    return Line.create(this.anchor, this.direction);\n  },\n  // Returns the result of translating the line by the given vector/array\n  translate: function (vector) {\n    var V = vector.elements || vector;\n    return Line.create([this.anchor.elements[0] + V[0], this.anchor.elements[1] + V[1], this.anchor.elements[2] + (V[2] || 0)], this.direction);\n  },\n  // Returns true if the line is parallel to the argument. Here, 'parallel to'\n  // means that the argument's direction is either parallel or antiparallel to\n  // the line's own direction. A line is parallel to a plane if the two do not\n  // have a unique intersection.\n  isParallelTo: function (obj) {\n    if (obj.normal || obj.start && obj.end) {\n      return obj.isParallelTo(this);\n    }\n\n    var theta = this.direction.angleFrom(obj.direction);\n    return Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision;\n  },\n  // Returns the line's perpendicular distance from the argument,\n  // which can be a point, a line or a plane\n  distanceFrom: function (obj) {\n    if (obj.normal || obj.start && obj.end) {\n      return obj.distanceFrom(this);\n    }\n\n    if (obj.direction) {\n      // obj is a line\n      if (this.isParallelTo(obj)) {\n        return this.distanceFrom(obj.anchor);\n      }\n\n      var N = this.direction.cross(obj.direction).toUnitVector().elements;\n      var A = this.anchor.elements,\n          B = obj.anchor.elements;\n      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      var A = this.anchor.elements,\n          D = this.direction.elements;\n      var PA1 = P[0] - A[0],\n          PA2 = P[1] - A[1],\n          PA3 = (P[2] || 0) - A[2];\n      var modPA = Math.sqrt(PA1 * PA1 + PA2 * PA2 + PA3 * PA3);\n      if (modPA === 0) return 0; // Assumes direction vector is normalized\n\n      var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;\n      var sin2 = 1 - cosTheta * cosTheta;\n      return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));\n    }\n  },\n  // Returns true iff the argument is a point on the line, or if the argument\n  // is a line segment lying within the receiver\n  contains: function (obj) {\n    if (obj.start && obj.end) {\n      return this.contains(obj.start) && this.contains(obj.end);\n    }\n\n    var dist = this.distanceFrom(obj);\n    return dist !== null && dist <= Sylvester.precision;\n  },\n  // Returns the distance from the anchor of the given point. Negative values are\n  // returned for points that are in the opposite direction to the line's direction from\n  // the line's anchor point.\n  positionOf: function (point) {\n    if (!this.contains(point)) {\n      return null;\n    }\n\n    var P = point.elements || point;\n    var A = this.anchor.elements,\n        D = this.direction.elements;\n    return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];\n  },\n  // Returns true iff the line lies in the given plane\n  liesIn: function (plane) {\n    return plane.contains(this);\n  },\n  // Returns true iff the line has a unique point of intersection with the argument\n  intersects: function (obj) {\n    if (obj.normal) {\n      return obj.intersects(this);\n    }\n\n    return !this.isParallelTo(obj) && this.distanceFrom(obj) <= Sylvester.precision;\n  },\n  // Returns the unique intersection point with the argument, if one exists\n  intersectionWith: function (obj) {\n    if (obj.normal || obj.start && obj.end) {\n      return obj.intersectionWith(this);\n    }\n\n    if (!this.intersects(obj)) {\n      return null;\n    }\n\n    var P = this.anchor.elements,\n        X = this.direction.elements,\n        Q = obj.anchor.elements,\n        Y = obj.direction.elements;\n    var X1 = X[0],\n        X2 = X[1],\n        X3 = X[2],\n        Y1 = Y[0],\n        Y2 = Y[1],\n        Y3 = Y[2];\n    var PsubQ1 = P[0] - Q[0],\n        PsubQ2 = P[1] - Q[1],\n        PsubQ3 = P[2] - Q[2];\n    var XdotQsubP = -X1 * PsubQ1 - X2 * PsubQ2 - X3 * PsubQ3;\n    var YdotPsubQ = Y1 * PsubQ1 + Y2 * PsubQ2 + Y3 * PsubQ3;\n    var XdotX = X1 * X1 + X2 * X2 + X3 * X3;\n    var YdotY = Y1 * Y1 + Y2 * Y2 + Y3 * Y3;\n    var XdotY = X1 * Y1 + X2 * Y2 + X3 * Y3;\n    var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);\n    return Vector.create([P[0] + k * X1, P[1] + k * X2, P[2] + k * X3]);\n  },\n  // Returns the point on the line that is closest to the given point or line/line segment\n  pointClosestTo: function (obj) {\n    if (obj.start && obj.end) {\n      // obj is a line segment\n      var P = obj.pointClosestTo(this);\n      return P === null ? null : this.pointClosestTo(P);\n    } else if (obj.direction) {\n      // obj is a line\n      if (this.intersects(obj)) {\n        return this.intersectionWith(obj);\n      }\n\n      if (this.isParallelTo(obj)) {\n        return null;\n      }\n\n      var D = this.direction.elements,\n          E = obj.direction.elements;\n      var D1 = D[0],\n          D2 = D[1],\n          D3 = D[2],\n          E1 = E[0],\n          E2 = E[1],\n          E3 = E[2]; // Create plane containing obj and the shared normal and intersect this with it\n      // Thank you: http://www.cgafaq.info/wiki/Line-line_distance\n\n      var x = D3 * E1 - D1 * E3,\n          y = D1 * E2 - D2 * E1,\n          z = D2 * E3 - D3 * E2;\n      var N = [x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1];\n      var P = Plane.create(obj.anchor, N);\n      return P.intersectionWith(this);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n\n      if (this.contains(P)) {\n        return Vector.create(P);\n      }\n\n      var A = this.anchor.elements,\n          D = this.direction.elements;\n      var D1 = D[0],\n          D2 = D[1],\n          D3 = D[2],\n          A1 = A[0],\n          A2 = A[1],\n          A3 = A[2];\n      var x = D1 * (P[1] - A2) - D2 * (P[0] - A1),\n          y = D2 * ((P[2] || 0) - A3) - D3 * (P[1] - A2),\n          z = D3 * (P[0] - A1) - D1 * ((P[2] || 0) - A3);\n      var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);\n      var k = this.distanceFrom(P) / V.modulus();\n      return Vector.create([P[0] + V.elements[0] * k, P[1] + V.elements[1] * k, (P[2] || 0) + V.elements[2] * k]);\n    }\n  },\n  // Returns a copy of the line rotated by t radians about the given line. Works by\n  // finding the argument's closest point to this line's anchor point (call this C) and\n  // rotating the anchor about C. Also rotates the line's direction about the argument's.\n  // Be careful with this - the rotation axis' direction affects the outcome!\n  rotate: function (t, line) {\n    // If we're working in 2D\n    if (typeof line.direction == 'undefined') {\n      line = Line.create(line.to3D(), Vector.k);\n    }\n\n    var R = Matrix.Rotation(t, line.direction).elements;\n    var C = line.pointClosestTo(this.anchor).elements;\n    var A = this.anchor.elements,\n        D = this.direction.elements;\n    var C1 = C[0],\n        C2 = C[1],\n        C3 = C[2],\n        A1 = A[0],\n        A2 = A[1],\n        A3 = A[2];\n    var x = A1 - C1,\n        y = A2 - C2,\n        z = A3 - C3;\n    return Line.create([C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z, C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z, C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z], [R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2], R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2], R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]]);\n  },\n  // Returns a copy of the line with its direction vector reversed.\n  // Useful when using lines for rotations.\n  reverse: function () {\n    return Line.create(this.anchor, this.direction.x(-1));\n  },\n  // Returns the line's reflection in the given point or line\n  reflectionIn: function (obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var A = this.anchor.elements,\n          D = this.direction.elements;\n      var A1 = A[0],\n          A2 = A[1],\n          A3 = A[2],\n          D1 = D[0],\n          D2 = D[1],\n          D3 = D[2];\n      var newA = this.anchor.reflectionIn(obj).elements; // Add the line's direction vector to its anchor, then mirror that in the plane\n\n      var AD1 = A1 + D1,\n          AD2 = A2 + D2,\n          AD3 = A3 + D3;\n      var Q = obj.pointClosestTo([AD1, AD2, AD3]).elements;\n      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];\n      return Line.create(newA, newD);\n    } else if (obj.direction) {\n      // obj is a line - reflection obtained by rotating PI radians about obj\n      return this.rotate(Math.PI, obj);\n    } else {\n      // obj is a point - just reflect the line's anchor in it\n      var P = obj.elements || obj;\n      return Line.create(this.anchor.reflectionIn([P[0], P[1], P[2] || 0]), this.direction);\n    }\n  },\n  // Set the line's anchor point and direction.\n  setVectors: function (anchor, direction) {\n    // Need to do this so that line's properties are not\n    // references to the arguments passed in\n    anchor = Vector.create(anchor);\n    direction = Vector.create(direction);\n\n    if (anchor.elements.length == 2) {\n      anchor.elements.push(0);\n    }\n\n    if (direction.elements.length == 2) {\n      direction.elements.push(0);\n    }\n\n    if (anchor.elements.length > 3 || direction.elements.length > 3) {\n      return null;\n    }\n\n    var mod = direction.modulus();\n\n    if (mod === 0) {\n      return null;\n    }\n\n    this.anchor = anchor;\n    this.direction = Vector.create([direction.elements[0] / mod, direction.elements[1] / mod, direction.elements[2] / mod]);\n    return this;\n  }\n}; // Constructor function\n\nLine.create = function (anchor, direction) {\n  var L = new Line();\n  return L.setVectors(anchor, direction);\n}; // Axes\n\n\nLine.X = Line.create(Vector.Zero(3), Vector.i);\nLine.Y = Line.create(Vector.Zero(3), Vector.j);\nLine.Z = Line.create(Vector.Zero(3), Vector.k);\nmodule.exports = Line;","map":{"version":3,"sources":["/Users/merjem/chat_application/react/node_modules/sylvester/lib/node-sylvester/line.js"],"names":["Vector","require","Matrix","Plane","Sylvester","Line","prototype","eql","line","isParallelTo","contains","anchor","dup","create","direction","translate","vector","V","elements","obj","normal","start","end","theta","angleFrom","Math","abs","precision","PI","distanceFrom","N","cross","toUnitVector","A","B","P","D","PA1","PA2","PA3","modPA","sqrt","cosTheta","sin2","dist","positionOf","point","liesIn","plane","intersects","intersectionWith","X","Q","Y","X1","X2","X3","Y1","Y2","Y3","PsubQ1","PsubQ2","PsubQ3","XdotQsubP","YdotPsubQ","XdotX","YdotY","XdotY","k","pointClosestTo","E","D1","D2","D3","E1","E2","E3","x","y","z","A1","A2","A3","modulus","rotate","t","to3D","R","Rotation","C","C1","C2","C3","reverse","reflectionIn","newA","AD1","AD2","AD3","newD","setVectors","length","push","mod","L","Zero","i","j","Z","module","exports"],"mappings":"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","sourcesContent":["// Copyright (c) 2011, Chris Umbel, James Coglan\nvar Vector = require('./vector');\nvar Matrix = require('./matrix');\nvar Plane = require('./plane');\nvar Sylvester = require('./sylvester');\n\n// Line class - depends on Vector, and some methods require Matrix and Plane.\n\nfunction Line() {}\nLine.prototype = {\n\n  // Returns true if the argument occupies the same space as the line\n  eql: function(line) {\n    return (this.isParallelTo(line) && this.contains(line.anchor));\n  },\n\n  // Returns a copy of the line\n  dup: function() {\n    return Line.create(this.anchor, this.direction);\n  },\n\n  // Returns the result of translating the line by the given vector/array\n  translate: function(vector) {\n    var V = vector.elements || vector;\n    return Line.create([\n      this.anchor.elements[0] + V[0],\n      this.anchor.elements[1] + V[1],\n      this.anchor.elements[2] + (V[2] || 0)\n    ], this.direction);\n  },\n\n  // Returns true if the line is parallel to the argument. Here, 'parallel to'\n  // means that the argument's direction is either parallel or antiparallel to\n  // the line's own direction. A line is parallel to a plane if the two do not\n  // have a unique intersection.\n  isParallelTo: function(obj) {\n    if (obj.normal || (obj.start && obj.end)) { return obj.isParallelTo(this); }\n    var theta = this.direction.angleFrom(obj.direction);\n    return (Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision);\n  },\n\n  // Returns the line's perpendicular distance from the argument,\n  // which can be a point, a line or a plane\n  distanceFrom: function(obj) {\n    if (obj.normal || (obj.start && obj.end)) { return obj.distanceFrom(this); }\n    if (obj.direction) {\n      // obj is a line\n      if (this.isParallelTo(obj)) { return this.distanceFrom(obj.anchor); }\n      var N = this.direction.cross(obj.direction).toUnitVector().elements;\n      var A = this.anchor.elements, B = obj.anchor.elements;\n      return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      var A = this.anchor.elements, D = this.direction.elements;\n      var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];\n      var modPA = Math.sqrt(PA1*PA1 + PA2*PA2 + PA3*PA3);\n      if (modPA === 0) return 0;\n      // Assumes direction vector is normalized\n      var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;\n      var sin2 = 1 - cosTheta*cosTheta;\n      return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));\n    }\n  },\n\n  // Returns true iff the argument is a point on the line, or if the argument\n  // is a line segment lying within the receiver\n  contains: function(obj) {\n    if (obj.start && obj.end) { return this.contains(obj.start) && this.contains(obj.end); }\n    var dist = this.distanceFrom(obj);\n    return (dist !== null && dist <= Sylvester.precision);\n  },\n\n  // Returns the distance from the anchor of the given point. Negative values are\n  // returned for points that are in the opposite direction to the line's direction from\n  // the line's anchor point.\n  positionOf: function(point) {\n    if (!this.contains(point)) { return null; }\n    var P = point.elements || point;\n    var A = this.anchor.elements, D = this.direction.elements;\n    return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];\n  },\n\n  // Returns true iff the line lies in the given plane\n  liesIn: function(plane) {\n    return plane.contains(this);\n  },\n\n  // Returns true iff the line has a unique point of intersection with the argument\n  intersects: function(obj) {\n    if (obj.normal) { return obj.intersects(this); }\n    return (!this.isParallelTo(obj) && this.distanceFrom(obj) <= Sylvester.precision);\n  },\n\n  // Returns the unique intersection point with the argument, if one exists\n  intersectionWith: function(obj) {\n    if (obj.normal || (obj.start && obj.end)) { return obj.intersectionWith(this); }\n    if (!this.intersects(obj)) { return null; }\n    var P = this.anchor.elements, X = this.direction.elements,\n        Q = obj.anchor.elements, Y = obj.direction.elements;\n    var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];\n    var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];\n    var XdotQsubP = - X1*PsubQ1 - X2*PsubQ2 - X3*PsubQ3;\n    var YdotPsubQ = Y1*PsubQ1 + Y2*PsubQ2 + Y3*PsubQ3;\n    var XdotX = X1*X1 + X2*X2 + X3*X3;\n    var YdotY = Y1*Y1 + Y2*Y2 + Y3*Y3;\n    var XdotY = X1*Y1 + X2*Y2 + X3*Y3;\n    var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);\n    return Vector.create([P[0] + k*X1, P[1] + k*X2, P[2] + k*X3]);\n  },\n\n  // Returns the point on the line that is closest to the given point or line/line segment\n  pointClosestTo: function(obj) {\n    if (obj.start && obj.end) {\n      // obj is a line segment\n      var P = obj.pointClosestTo(this);\n      return (P === null) ? null : this.pointClosestTo(P);\n    } else if (obj.direction) {\n      // obj is a line\n      if (this.intersects(obj)) { return this.intersectionWith(obj); }\n      if (this.isParallelTo(obj)) { return null; }\n      var D = this.direction.elements, E = obj.direction.elements;\n      var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];\n      // Create plane containing obj and the shared normal and intersect this with it\n      // Thank you: http://www.cgafaq.info/wiki/Line-line_distance\n      var x = (D3 * E1 - D1 * E3), y = (D1 * E2 - D2 * E1), z = (D2 * E3 - D3 * E2);\n      var N = [x * E3 - y * E2, y * E1 - z * E3, z * E2 - x * E1];\n      var P = Plane.create(obj.anchor, N);\n      return P.intersectionWith(this);\n    } else {\n      // obj is a point\n      var P = obj.elements || obj;\n      if (this.contains(P)) { return Vector.create(P); }\n      var A = this.anchor.elements, D = this.direction.elements;\n      var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];\n      var x = D1 * (P[1]-A2) - D2 * (P[0]-A1), y = D2 * ((P[2] || 0) - A3) - D3 * (P[1]-A2),\n          z = D3 * (P[0]-A1) - D1 * ((P[2] || 0) - A3);\n      var V = Vector.create([D2 * x - D3 * z, D3 * y - D1 * x, D1 * z - D2 * y]);\n      var k = this.distanceFrom(P) / V.modulus();\n      return Vector.create([\n        P[0] + V.elements[0] * k,\n        P[1] + V.elements[1] * k,\n        (P[2] || 0) + V.elements[2] * k\n      ]);\n    }\n  },\n\n  // Returns a copy of the line rotated by t radians about the given line. Works by\n  // finding the argument's closest point to this line's anchor point (call this C) and\n  // rotating the anchor about C. Also rotates the line's direction about the argument's.\n  // Be careful with this - the rotation axis' direction affects the outcome!\n  rotate: function(t, line) {\n    // If we're working in 2D\n    if (typeof(line.direction) == 'undefined') { line = Line.create(line.to3D(), Vector.k); }\n    var R = Matrix.Rotation(t, line.direction).elements;\n    var C = line.pointClosestTo(this.anchor).elements;\n    var A = this.anchor.elements, D = this.direction.elements;\n    var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];\n    var x = A1 - C1, y = A2 - C2, z = A3 - C3;\n    return Line.create([\n      C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,\n      C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,\n      C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z\n    ], [\n      R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2],\n      R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2],\n      R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]\n    ]);\n  },\n\n  // Returns a copy of the line with its direction vector reversed.\n  // Useful when using lines for rotations.\n  reverse: function() {\n    return Line.create(this.anchor, this.direction.x(-1));\n  },\n\n  // Returns the line's reflection in the given point or line\n  reflectionIn: function(obj) {\n    if (obj.normal) {\n      // obj is a plane\n      var A = this.anchor.elements, D = this.direction.elements;\n      var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];\n      var newA = this.anchor.reflectionIn(obj).elements;\n      // Add the line's direction vector to its anchor, then mirror that in the plane\n      var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;\n      var Q = obj.pointClosestTo([AD1, AD2, AD3]).elements;\n      var newD = [Q[0] + (Q[0] - AD1) - newA[0], Q[1] + (Q[1] - AD2) - newA[1], Q[2] + (Q[2] - AD3) - newA[2]];\n      return Line.create(newA, newD);\n    } else if (obj.direction) {\n      // obj is a line - reflection obtained by rotating PI radians about obj\n      return this.rotate(Math.PI, obj);\n    } else {\n      // obj is a point - just reflect the line's anchor in it\n      var P = obj.elements || obj;\n      return Line.create(this.anchor.reflectionIn([P[0], P[1], (P[2] || 0)]), this.direction);\n    }\n  },\n\n  // Set the line's anchor point and direction.\n  setVectors: function(anchor, direction) {\n    // Need to do this so that line's properties are not\n    // references to the arguments passed in\n    anchor = Vector.create(anchor);\n    direction = Vector.create(direction);\n    if (anchor.elements.length == 2) {anchor.elements.push(0); }\n    if (direction.elements.length == 2) { direction.elements.push(0); }\n    if (anchor.elements.length > 3 || direction.elements.length > 3) { return null; }\n    var mod = direction.modulus();\n    if (mod === 0) { return null; }\n    this.anchor = anchor;\n    this.direction = Vector.create([\n      direction.elements[0] / mod,\n      direction.elements[1] / mod,\n      direction.elements[2] / mod\n    ]);\n    return this;\n  }\n};\n\n// Constructor function\nLine.create = function(anchor, direction) {\n  var L = new Line();\n  return L.setVectors(anchor, direction);\n};\n\n// Axes\nLine.X = Line.create(Vector.Zero(3), Vector.i);\nLine.Y = Line.create(Vector.Zero(3), Vector.j);\nLine.Z = Line.create(Vector.Zero(3), Vector.k);\n\nmodule.exports = Line;\n"]},"metadata":{},"sourceType":"script"}